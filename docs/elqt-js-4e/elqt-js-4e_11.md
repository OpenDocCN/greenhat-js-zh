# 第十一章：模块

理想情况下，程序应具有清晰、简单的结构。它的工作原理容易解释，每个部分都扮演着明确的角色。

在实践中，程序是有机增长的。随着程序员识别新的需求，功能块被逐步添加。保持这样的程序结构良好需要持续的关注和努力。这项工作只有在将来、下次有人处理该程序时才会得到回报，因此很容易忽视它，让程序的各个部分深度纠缠。

这造成了两个实际问题。首先，理解一个纠缠的系统很困难。如果一切都能相互触及，那么很难孤立地看待任何特定的部分。你被迫建立对整个事物的整体理解。其次，如果你想在另一种情况下使用这样的程序的任何功能，重写它可能比试图将其从上下文中解开要容易。

“大球泥土”这个短语常用来形容这样的庞大、无结构的程序。一切都粘在一起，当你试图挑出一部分时，整个东西就会散架，你最终只会搞得一团糟。

### 模块化程序

`模块`是试图避免这些问题的一个尝试。一个模块是一段程序，指定它依赖于哪些其他部分以及它为其他模块提供哪些功能（它的`接口`）。

模块接口与对象接口有很多相似之处，正如我们在第六章中看到的。它们将模块的一部分公开给外部世界，而将其余部分保留为私有。

但是，一个模块为其他模块提供的接口只是故事的一部分。一个好的模块系统还要求模块指定`它们`使用其他模块的哪些代码。这些关系称为`依赖`。如果模块`A`使用模块`B`的功能，就说模块`A`依赖于该模块。当这些在模块内部被明确指定时，可以用来确定使用特定模块所需的其他模块，并自动加载依赖项。

当模块之间的交互方式是明确的时，系统就更像乐高，组件通过明确定义的连接器相互作用，而不像泥土那样，所有东西都混在一起。

### ES模块

原始的JavaScript语言没有模块的概念。所有脚本都在同一个作用域内运行，访问在另一个脚本中定义的函数是通过引用该脚本创建的全局绑定来完成的。这积极鼓励了代码的意外、难以察觉的纠缠，并导致了不同脚本尝试使用相同绑定名称等问题。

自`ECMAScript 2015`以来，JavaScript支持两种不同类型的程序。`脚本`以旧的方式运行：它们的绑定在全局范围内定义，并且无法直接引用其他脚本。`模块`拥有自己的独立范围，并支持`import`和`export`关键字，这在脚本中不可用，以声明它们的依赖关系和接口。这个模块系统通常称为`ES模块`（`ES`代表`ECMAScript`）。

一个模块化程序由多个这样的模块组成，通过它们的导入和导出连接在一起。

以下示例模块在日期名称和数字之间转换（如`Date`的`getDay`方法返回的）。它定义了一个不属于其接口的常量，以及两个属于其接口的函数。它没有依赖关系。

```js
const names = ["Sunday", "Monday", "Tuesday", "Wednesday",
               "Thursday", "Friday", "Saturday"];

export function dayName(number) {
  return names[number];
}
export function dayNumber(name) {
  return names.indexOf(name);
}
```

`export`关键字可以放在函数、类或绑定定义前，表示该绑定是模块接口的一部分。这使得其他模块能够通过导入该绑定来使用它。

```js
import {dayName} from "./dayname.js";
let now = new Date();
console.log(`Today is ${dayName(now.getDay())}`);
// → Today is Monday
```

`import`关键字后跟花括号内的绑定名称列表，使来自另一个模块的绑定在当前模块中可用。模块由引号字符串标识。

这样的模块名称解析为实际程序的方式因平台而异。浏览器将它们视为网址，而`Node.js`将其解析为文件。当你运行一个模块时，它所依赖的所有其他模块——以及那些模块所依赖的模块——都会被加载，导出的绑定将对导入它们的模块可用。

`import`和`export`声明不能出现在函数、循环或其他块内。它们在模块加载时立即解析，无论模块中的代码如何执行。为了反映这一点，它们必须仅出现在外部模块体内。

模块的接口因此由一组命名绑定组成，其他依赖于该模块的模块可以访问这些绑定。导入的绑定可以通过在名称后使用`as`来重命名，从而赋予它们一个新的本地名称。

```js
import {dayName as nomDeJour} from "./dayname.js";
console.log(nomDeJour(3));
// → Wednesday
```

模块也可以有一个名为`default`的特殊导出，通常用于仅导出单个绑定的模块。要定义默认导出，请在表达式、函数声明或类声明前写`export default`。

```js
export default ["Winter", "Spring", "Summer", "Autumn"];
```

这样的绑定通过省略名称周围的花括号来导入。

```js
import seasonNames from "./seasonname.js";
```

要同时导入模块中的所有绑定，可以使用`import *`。你提供一个名称，这个名称将绑定到一个持有所有模块导出的对象上。当你使用很多不同的导出时，这非常有用。

```js
import * as dayName from ".dayname.js";
console.log(dayName.dayName(3));
// → Wednesday
```

### 包

将程序构建为多个独立部分，并能够单独运行其中一些部分的一个优点是，你可能能够在不同程序中使用相同的部分。

那么，如何设置这个呢？假设我想在另一个程序中使用第九章中的`parseINI`函数。如果很清楚这个函数的依赖（在这种情况下，没有），我可以直接把该模块复制到我的新项目中并使用。但是，如果我在代码中发现了错误，我可能会在我当时正在工作的程序中修复它，却忘了在其他程序中也修复。

一旦你开始复制代码，你会迅速发现自己在浪费时间和精力来移动副本并保持它们的更新。这就是`包`的用武之地。一个`包`是一块可以分发（复制和安装）的代码。它可能包含一个或多个`模块`，并包含有关其依赖于其他`包`的信息。`包`通常还会附带文档，解释它的功能，以便那些没有编写它的人也能够使用。

当在一个`包`中发现问题或添加新特性时，该`包`会被更新。现在，依赖于它的程序（也可能是`包`）可以复制新版本，以获得对代码所做改进的访问。

以这种方式工作需要基础设施。我们需要一个地方来存储和查找`包`，以及一个方便的方式来安装和升级它们。在 JavaScript 世界中，这一基础设施由`NPM`提供（`[www.npmjs.com](https://www.npmjs.com)`）。

`NPM`有两个功能：一个是你可以下载（和上传）`包`的在线服务，另一个是一个程序（与`Node.js`捆绑在一起），帮助你安装和管理这些`包`。

截至目前，`NPM`上有超过三百万个不同的`包`。公平地说，其中大部分是无用的。但是几乎所有有用的、公开可用的 JavaScript `包`都可以在`NPM`上找到。例如，与我们在第九章中构建的`INI`文件解析器类似的一个解析器可以在包名为`ini`下找到。

第二十章将展示如何使用`npm`命令行程序在本地安装这些`包`。

拥有可供下载的高质量`包`是非常有价值的。这意味着我们通常可以避免重新发明一个已经被 100 人写过的程序，并且可以在按下几下键的情况下获得一个稳固、经过良好测试的实现。

软件复制成本低，因此一旦有人编写了它，分发给其他人就是一个高效的过程。不过，最初编写它`确实`是一项工作，而回应那些发现代码问题或希望提出新特性的人则需要更多的工作。

默认情况下，你拥有自己编写代码的版权，其他人只能在获得你的许可后使用它。但是，因为有些人很友善，且发布好的软件可以让你在程序员中小有名气，许多`包`都在允许其他人使用的许可证下发布。

`NPM`上的大多数代码以这种方式获得许可。一些许可证要求你在基于该`包`构建的代码上也以相同许可证发布。其他许可证要求较少，仅要求在分发代码时保留许可证。JavaScript 社区主要使用后者类型的许可证。在使用其他人的`包`时，请确保了解其许可证。

现在，我们可以使用`NPM`上的一个解析`INI`文件的`模块`，而不是自己编写一个。

```js
import {parse} from "ini";

console.log(parse("x = 10\ny = 20"));
// → {x: "10", y: "20"}
```

### `CommonJS`模块

在`2015`年之前，当 JavaScript 语言没有内置`模块`系统时，人们已经在 JavaScript 中构建了大型系统。为了使其可行，他们`需要`模块。

社区在语言之上设计了自己的即兴`模块`系统。这些使用函数为`模块`创建局部作用域，并使用常规对象来表示`模块`接口。

起初，人们只是手动将整个`模块`包裹在一个`立即调用函数表达式`中，以创建`模块`的作用域，并将接口对象分配给一个全局变量。

```js
const weekDay = function() {
  const names = ["Sunday", "Monday", "Tuesday", "Wednesday",
                 "Thursday", "Friday", "Saturday"];
  return {
    name(number) { return names[number]; },
    number(name) { return names.indexOf(name); }
  };
}();

console.log(weekDay.name(weekDay.number("Sunday")));
// → Sunday
```

这种`模块`风格提供了一定程度的隔离，但并未声明依赖关系。相反，它只是将其接口放入全局作用域，并期望其依赖关系（如果有的话）也这样做。这并不是理想的。

如果我们实现自己的`模块`加载器，我们可以做得更好。最广泛使用的附加 JavaScript`模块`方法称为`CommonJS`模块。`Node.js`从一开始就使用这个`模块`系统（虽然现在也知道如何加载 ES`模块`），这是许多`NPM`包使用的`模块`系统。

`CommonJS`模块看起来像一个常规脚本，但它可以访问两个绑定，以便与其他模块进行交互。第一个是一个名为`require`的函数。当你使用依赖模块的名称调用它时，它会确保模块被加载并返回其接口。第二个是一个名为`exports`的对象，这是模块的接口对象。它最开始是空的，你向其添加属性以定义导出的值。

这个`CommonJS`示例模块提供了一个日期格式化函数。它使用了来自`NPM`的两个包——`ordinal`将数字转换为`"1st"`和`"2nd"`等字符串，而`date-names`则获取工作日和月份的英文名称。它导出一个单一的函数`formatDate`，接受一个`Date`对象和一个模板字符串。

模板字符串可以包含指导格式的代码，例如`YYYY`表示完整年份，`Do`表示月份的序数日。你可以给它一个像`"MMMM Do YYYY"`的字符串，以获得类似于`"2017 年 11 月 22 日"`的输出。

```js
const ordinal = require("ordinal");
const {days, months} = require("date-names");

exports.formatDate = function(date, format) {
  return format.replace(/YYYY|M(MMM)?|Do?|dddd/g, tag => {
    if (tag == "YYYY") return date.getFullYear();
    if (tag == "M") return date.getMonth();
    if (tag == "MMMM") return months[date.getMonth()];
    if (tag == "D") return date.getDate();
    if (tag == "Do") return ordinal(date.getDate());
    if (tag == "dddd") return days[date.getDay()];
  });
};
```

`ordinal`的接口是一个单一的函数，而`date-names`导出的是一个包含多个内容的对象——天和月是名称的数组。解构在创建导入接口的绑定时非常方便。

`模块`将其接口函数添加到`exports`中，以便依赖于它的`模块`可以访问它。我们可以这样使用该`模块`：

```js
const {formatDate} = require("./format-date.js");

console.log(formatDate(new Date(2017, 9, 13),
                       "dddd the Do"));
// → Friday the 13th
```

`CommonJS`实现了一个`模块`加载器，当加载`模块`时，将其代码封装在一个函数中（为其提供自己的局部作用域），并将`require`和`exports`绑定作为参数传递给该函数。

如果我们假设有一个 `readFile` 函数，可以通过名称读取文件并返回其内容，我们可以像这样定义一个简化的 `require` 形式：

```js
function require(name) {
  if (!(name in require.cache)) {
    let code = readFile(name);
    let exports = require.cache[name] = {};
    let wrapper = Function("require, exports", code);
    wrapper(require, exports);
  }
  return require.cache[name];
}
require.cache = Object.create(null);
```

`Function` 是一个内置的 JavaScript 函数，它接受一个以逗号分隔的字符串形式的参数列表和一个包含函数体的字符串，并返回一个带有这些参数和该函数体的函数值。这是一个有趣的概念——它允许程序从字符串数据中创建新的程序片段——但也是一个危险的概念，因为如果有人能欺骗你的程序将他们提供的字符串放入 `Function` 中，他们就能让程序执行任何他们想要的操作。

标准的 JavaScript 并没有提供像 `readFile` 这样的函数，但不同的 JavaScript 环境，如浏览器和 Node.js，提供了各自访问文件的方式。这个例子假装 `readFile` 存在。

为了避免多次加载相同的模块，`require`保持已加载模块的存储（缓存）。调用时，它首先检查请求的模块是否已加载，如果没有，则加载它。这涉及读取模块的代码，将其封装在一个函数中，并调用它。

通过将 `require` 和 `exports` 定义为生成的包装函数的参数（并在调用时传递适当的值），加载器确保这些绑定在模块的作用域中可用。

该系统与 ES 模块之间的一个重要区别是，ES 模块的导入在模块的脚本开始运行之前发生，而 `require` 是一个普通函数，在模块已经运行时调用。与导入声明不同，`require` 调用`可以`出现在函数内部，依赖项的名称可以是任何计算结果为字符串的表达式，而导入只允许普通的带引号字符串。

JavaScript 社区从 CommonJS 风格过渡到 ES 模块的过程比较缓慢且略显粗糙。幸运的是，现在大多数流行的 NPM 包都以 ES 模块的形式提供其代码，Node.js 也允许 ES 模块从 CommonJS 模块中导入。虽然 CommonJS 代码仍然会出现，但已经没有真正的理由再以这种风格编写新程序。

### 构建与打包

许多 JavaScript 包在技术上并不是用 JavaScript 编写的。诸如 TypeScript 之类的语言扩展，在`第八章`中提到的类型检查方言，被广泛使用。人们通常会在新语言特性被实际添加到运行 JavaScript 的平台之前，就开始使用计划中的新特性。为了实现这一点，他们会`编译`他们的代码，将其从所选的 JavaScript 方言转换为普通的 JavaScript，甚至是早期版本的 JavaScript，以便浏览器能够运行它。

在网页中包含由 200 个不同文件组成的模块化程序会产生自身的问题。如果从网络上获取一个文件需要 50 毫秒，那么加载整个程序需要 10 秒钟，或者如果你能够同时加载几个文件，可能会少一些。这是很多浪费的时间。因为获取一个大文件往往比获取许多小文件要快，网页程序员开始使用工具将他们精心拆分成模块的程序合并成一个大文件，然后再发布到网络上。这类工具被称为`打包工具`。

我们可以更进一步。除了文件数量，文件的`大小`也决定了它们在网络上传输的速度。因此，JavaScript 社区发明了`压缩工具`。这些工具通过自动删除注释和空格、重命名绑定以及用占用更少空间的等效代码替换代码片段，使 JavaScript 程序变得更小。

在 NPM 包中或在网页上运行的代码经历过`多次`转换阶段是并不少见——从现代 JavaScript 转换为历史 JavaScript，将模块合并为一个文件，以及压缩代码。在本书中我们不会详细介绍这些工具，因为它们种类繁多，流行的工具也会定期变化。只需知道这些工具的存在，并在需要时查找它们。

### 模块设计

结构化程序是编程中更微妙的方面之一。任何非平凡的功能都可以以多种方式组织。

良好的程序设计是主观的——涉及权衡和品味的问题。学习结构良好的设计价值的最好方法是阅读或参与大量程序，并注意什么有效，什么无效。不要假设一个痛苦的混乱是“就是这样的”。通过更多思考，你可以改善几乎所有事物的结构。

模块设计的一个方面是易用性。如果你设计的东西是为了让多个人使用——或者即使是你自己，在三个月后当你不再记得你所做的具体事情时——那么如果你的接口简单且可预测，那将会很有帮助。

这可能意味着遵循现有的约定。一个好的例子是`ini`包。这个模块通过提供解析和字符串化（以写入 INI 文件）函数，模仿标准 JSON 对象，并且像 JSON 一样，在字符串和普通对象之间进行转换。接口小而熟悉，使用一次后，你可能会记住如何使用它。

即使没有标准函数或广泛使用的包可以模仿，你也可以通过使用简单的数据结构并专注于单一功能来保持模块的可预测性。比如，`NPM`上许多`INI`文件解析模块提供一个直接从硬盘读取并解析文件的函数。这使得在浏览器中使用这些模块变得不可能，因为我们没有直接的文件系统访问权限，并增加了复杂性，而这本可以通过`组合`文件读取功能来更好地解决。

这指出了模块设计的另一个有用方面——与其他代码组合的简便性。专注于计算值的模块适用于比执行复杂操作和副作用的大模块更广泛的程序场景。一个坚持从磁盘读取文件的`INI`文件读取器在文件内容来自其他来源的情况下毫无用处。

相关地，有状态对象有时是有用甚至必要的，但如果可以用函数完成的事情，就应该使用函数。`NPM`上几个`INI`文件读取器提供了一种接口风格，要求你首先创建一个对象，然后将文件加载到对象中，最后使用专门的方法获取结果。这种情况在面向对象传统中很常见，而且非常糟糕。你不得不进行将对象通过不同状态移动的仪式，而不是简单地调用一个函数并继续。而且，由于数据现在被封装在专门的对象类型中，所有与之交互的代码都必须了解该类型，造成不必要的相互依赖。

经常，定义新的数据结构是不可避免的——语言标准只提供少数基本结构，许多数据类型必须比数组或映射更复杂。但当数组足够时，就用数组。

一个稍微复杂的数据结构的例子是来自`第七章`的图。在`JavaScript`中，没有单一明显的方法来表示图。在那一章中，我们使用了一个对象，其属性持有字符串数组——可从该节点到达的其他节点。

`NPM`上有几个不同的路径查找包，但没有一个使用这种图格式。它们通常允许图的边具有权重，即与之相关的成本或距离。这在我们的表示中是不可行的。

例如，有`dijkstrajs`包。一种著名的路径查找方法，与我们的`findRoute`函数非常相似，称为`迪杰斯特拉算法`，以最早将其写下的`Edsger Dijkstra`命名。`js`后缀通常被添加到包名中，以表明它们是用`JavaScript`编写的。这个`dijkstrajs`包使用类似于我们的图格式，但它使用的是属性值为数字的对象——边的权重。

如果我们想使用那个包，就必须确保我们的图以它所期望的格式存储。所有边的权重相同，因为我们的简化模型将每条道路视为具有相同成本（一个转弯）。

```js
const {find_path} = require("dijkstrajs");

let graph = {};
for (let node of Object.keys(roadGraph)) {
  let edges = graph[node] = {};
  for (let dest of roadGraph[node]) {
    edges[dest] = 1;
  }
}

console.log(find_path(graph, "Post Office", "Cabin"));
// → ["Post Office", "Alice's House", "Cabin"]
```

这可能成为组合的障碍——当各种包使用不同的数据结构描述相似事物时，组合它们会很困难。因此，如果你想设计可组合性，了解其他人使用的数据结构，并在可能的情况下遵循他们的示例。

为程序设计合适的模块结构可能很困难。在你仍在探索问题的阶段，尝试不同的方案以查看什么有效时，你可能不想太过担心这个，因为保持一切有序可能会带来很大的干扰。一旦你有了感觉稳固的东西，那就是退后一步进行整理的好时机。

### 摘要

模块通过将代码分离为具有清晰接口和依赖关系的片段，为更大的程序提供结构。接口是模块对其他模块可见的部分，依赖关系是它所使用的其他模块。

因为`JavaScript`历史上没有提供模块系统，所以在其之上构建了`CommonJS`系统。然后在某个时刻它`确实`得到了内置系统，现在与`CommonJS`系统并存，但关系并不融洽。

包是可以独立分发的代码块。`NPM`是一个`JavaScript`包的库。你可以从中下载各种有用（和无用）的包。

### 练习

#### `一个模块化机器人`

这是项目从`第七章`创建的绑定：

```js
roads
buildGraph
roadGraph
VillageState
runRobot
randomPick
randomRobot
mailRoute
routeRobot
findRoute
goalOrientedRobot
```

如果你要把那个项目写成一个模块化程序，你会创建哪些模块？哪个模块依赖于哪个其他模块，它们的接口会是什么样子？

哪些部分可能在`NPM`上已有预写？你更愿意使用`NPM`包还是自己编写？

#### `道路模块`

基于`第七章`的示例编写一个`ES`模块，该模块包含道路数组并将表示它们的图数据结构导出为`roadGraph`。它依赖于一个导出函数`buildGraph`的模块`./graph.js`，该函数用于构建图。此函数期望一个由两个元素数组（道路的起点和终点）组成的数组。

#### `循环依赖`

循环依赖是一种情况，其中模块`A`依赖于`B`，而`B`也直接或间接依赖于`A`。许多模块系统简单地禁止这种情况，因为无论你选择哪种加载顺序，都无法确保在运行之前每个模块的依赖关系都已加载。

`CommonJS`模块允许有限形式的循环依赖。只要模块在加载完成之前不相互访问对方的接口，循环依赖是可以的。

本章前面给出的`require`函数支持这种类型的依赖循环。你能看出它是如何处理循环的吗？

`谁能静静等待泥沙沉淀？谁能保持静止直到行动的时刻？`

—老子，《道德经》

![图像](img/f0174-01.jpg)
